# 贪心算法

贪心策略一旦经过证明成立后，它就是一种高效的算法。
可惜的是，它需要证明后才能真正运用到题目的算法中。
一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。

求最小生成树的Prim算法和Kruskal算法都是漂亮的贪心算法。
贪心法的应用算法有Dijkstra的单源最短路径和Chvatal的贪心集合覆盖启发式

### 最小生成树



### 找零钱

>用的零钱尽可能少
>target = 666
>3张100的，10张50的，7张5元的，44张2元，99张1元

解法
>先用最大面额的

### 活动选择

> 某天要安排n个活动，要求安排的活动尽可能多
> 第k个活动的开始时间和结束时间分别是s[k],f[k]

解法
> 按照结束时间排序
> 每次安排最先结束的活动


### Dijkstra最短路径

```python
'''计算最短路径，采用邻接矩阵存储
若使用邻接表存储，然后使用最小堆存储未结束的点，会使find min distance更快，复杂度降为mlog(n)
'''

DIS = [	[0, 3, 10, 2], 
		[3, 0, 6, 1], 
		[10, 6, 0, 9], 
		[2, 1, 9, 0]]
print(DIS)

MIN_DIS = {}
for i in range(4):
    MIN_DIS[i] = DIS[i][0]
MIN_DIS.pop(0)

for i in range(len(DIS) - 1):
    cur_min = min(MIN_DIS.values())  # 找到当前剩下的最近的距离
    for key in MIN_DIS:
        if MIN_DIS[key] == cur_min:  # 找到对应的下标
            MIN_DIS.pop(key)  # 删除这个最小边的点
            print(key, cur_min)
            for least_dot in MIN_DIS:  # 更新距离
                if MIN_DIS[least_dot] > (DIS[key][least_dot] + cur_min):
                    MIN_DIS[least_dot] = (DIS[key][least_dot] + cur_min)
            break
```
