
编译原理

1. 源文件
2. 词法分析
3. 语法分析
4. 语义分析（先干啥在干啥）
5. 代码生成


协议的三要素：
1. 语法
2. 语义
3. 顺序


域名查找：
1. DNS
2. HTTPDNS 更精准

加密传输 HTTPS

这些都是应用层

会将包交给传输层处理， TCP和UDP   TCP会保证包一定会到达目的地，  传输层会根据端口识别应用程序


去国外要去海关
去外地要去网关

OS启动的时候， 会被DHCP配置IP地址， 以及默认的网关地址`192.168.1.1`


ARP,  根据IP查询MAC，  MAC广播， 相当于在局域网大喊一声

网关一般是个路由器 ，  路由表

路由协议： OSPF BGP

一点一点问路（路由器）， 最终到最终服务器所在的局域网


电商网站的请求处理的接待员是个Tomcat，  然后告诉相应的进程干什么活
	这里一般使用RPC框架通知
		RPC框架有基于HTTP协议的， 通知内容放到HTTP报文中
		也有基于TCP协议的， 直接放到TCP报文中



后续讲的顺序， 从底层到上层

1. 应用层
	1. DHCP
	2. HTTP
	3. HTTPS
	4. RTMP
	5. P2P
	6. DNS
	7. GTP
	8. RPC
2. 传输层
	1. UDP
	2. TCP
3. 网络层
	1. ICMP
	2. IP
	3. OSPF
	4. BGP
	5. IPSec
	6. GRE
4. 链路层
	1. ARP
	2. VLAN
	3. STP
5. 物理层
	1. 网络跳线



#todo
遗留问题： 当网络包到达下一个城管的时候， 明明知道接下来的城关的IP地址， 直接通过IP地址找就行了，  为啥还要通过本地的MAC地址呢？

答案： 不是因为路由器没有直连！！！ 实际到底是不是全部直接连接呢？？
猜测答案，  因为目标IP地址是最终的服务器IP地址，  下一条路由器只是下一条， 并不是最终的IP， 下一条的IP地址如果放到报文的目标IP地址上， 那当报文到了下一条之后， 就不知道最终的IP地址了。。 所以要查到下一跳的MAC， 到了之后再去问最终目标IP的下一条是哪个路由器，  每到了目标IP的设备， 都去问目标IP是不是你， 不是的话再往哪里走？








